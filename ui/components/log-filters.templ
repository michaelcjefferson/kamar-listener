package components

import (
  "slices"
  "sort"
  "strconv"

  "github.com/mjefferson-whs/listener/internal/data"
)

templ LogFilters(logsMetadata *data.LogsMetadata, filters data.Filters) {
  {{
    type levelMeta struct {
      Level string
      Count int
    }
    var levelMetas []levelMeta
    for level, count := range logsMetadata.Levels {
      levelMetas = append(levelMetas, levelMeta{Level: level, Count: count})
    }
    sort.Slice(levelMetas, func(i, j int) bool {
      return levelMetas[i].Count > levelMetas[j].Count
    })

    type userMeta struct {
      UserID int
      Count int
    }
    var userMetas []userMeta
    for id, count := range logsMetadata.Users {
      userMetas = append(userMetas, userMeta{UserID: id, Count: count})
    }
    sort.Slice(userMetas, func(i, j int) bool {
      return userMetas[i].UserID < userMetas[j].UserID
    })
  }}

  <div class="filter-controls">
    <div class="level-filters">
      for _, l := range levelMetas {
        if slices.Contains(filters.LogFilters.Level, l.Level) {
          <button class="filter-button level-filter active" data-filter={ l.Level }>{ l.Level + " (" + strconv.Itoa(l.Count) + ")" }</button>
        } else {
          <button class="filter-button level-filter" data-filter={ l.Level }>{ l.Level + " (" + strconv.Itoa(l.Count) + ")" }</button>
        }
      }
    </div>
    <div class="user-filters">
      for _, u := range userMetas {
        if slices.Contains(filters.LogFilters.UserID, u.UserID) {
          <button class="filter-button user_id-filter active" data-filter={ strconv.Itoa(u.UserID) }>{ "User ID " +  strconv.Itoa(u.UserID) + " (" + strconv.Itoa(u.Count) + ")" }</button>
        } else {
          <button class="filter-button user_id-filter" data-filter={ strconv.Itoa(u.UserID) }>{ "User ID " +  strconv.Itoa(u.UserID) + " (" + strconv.Itoa(u.Count) + ")" }</button>
        }
      }
    </div>

    <div class="search-bar">
      <input type="text" name="message-search" value={filters.LogFilters.Search} id="message-search" placeholder="Search messages...">
    </div>
  </div>

  <script>
    document.querySelectorAll(".filter-button").forEach(button => {
      button.addEventListener("click", () => {
        button.classList.toggle("active");

        let activeFilters = {
          "level": [],
          "user_id": []
        }

        document.querySelectorAll(".filter-button.level-filter.active").forEach(button => {
          activeFilters["level"].push(button.getAttribute("data-filter"));
        });
        document.querySelectorAll(".filter-button.user_id-filter.active").forEach(button => {
          activeFilters["user_id"].push(button.getAttribute("data-filter"));
        });

        // sessionStorage.setItem("activeFilters", JSON.stringify(activeFilters));

        let params = new URLSearchParams();
        // Adding params in this way ensures that with multiple level params, it will be "level=INFO&level=ERROR" rather than "level=INFO,ERROR" - this makes it much easier for the echo router to pick out these params
        if (activeFilters["level"].length > 0) {
          activeFilters["level"].forEach(p => {
            params.append("level", p);
          });
        }
        if (activeFilters["user_id"].length > 0) {
          activeFilters["user_id"].forEach(p => {
            params.append("user_id", p);
          });
        }

        window.location.href = "/logs?" + params.toString();
        // let res = await fetch("/logs?" + params.toString());
        // if (res.ok) {
        //   window.location.href = "/logs?" + params.toString();
        // } else {
        //   console.log(res);
        // }
        // htmx.ajax("GET", "/logs?" + params.toString(), { target: "#logs-container", pushURL: true });
      });

    });
  </script>
}

// templ LogFilters(logsMetadata *data.LogsMetadata) {
//   <div class="filter-controls">
//     <div class="level-filters">
//       for k, v := range logsMetadata.Levels {
//         <button class="filter-button level-filter" data-filter={ k }>{ k + " (" + strconv.Itoa(v) + ")" }</button>
//       }
//     </div>
//     <div class="user-filters">
//       for k, v := range logsMetadata.Users {
//         <button class="filter-button user_id-filter" data-filter={ strconv.Itoa(k) }>{ "User ID " +  strconv.Itoa(k) + " (" + strconv.Itoa(v) + ")" }</button>
//       }
//     </div>
//     <div class="search-bar">
//       <input type="text" name="message-search" id="message-search" placeholder="Search messages...">
//     </div>
//   </div>

//   <script>
//     document.querySelectorAll(".filter-button").forEach(button => {
//       button.addEventListener("click", () => {
//         button.classList.toggle("active");

//         let activeFilters = {
//           "level": [],
//           "user_id": []
//         }

//         document.querySelectorAll(".filter-button.level-filter.active").forEach(button => {
//           activeFilters["level"].push(button.getAttribute("data-filter"));
//         });
//         document.querySelectorAll(".filter-button.user_id-filter.active").forEach(button => {
//           activeFilters["user_id"].push(button.getAttribute("data-filter"));
//         });

//         // sessionStorage.setItem("activeFilters", JSON.stringify(activeFilters));

//         let params = new URLSearchParams();
//         // Adding params in this way ensures that with multiple level params, it will be "level=INFO&level=ERROR" rather than "level=INFO,ERROR" - this makes it much easier for the echo router to pick out these params
//         if (activeFilters["level"].length > 0) {
//           activeFilters["level"].forEach(p => {
//             params.append("level", p);
//           });
//         }
//         if (activeFilters["user_id"].length > 0) {
//           activeFilters["user_id"].forEach(p => {
//             params.append("user_id", p);
//           });
//         }

//         htmx.ajax("GET", "/logs/partial?" + params.toString(), { target: "#logs-container", pushURL: true });
//       });

//     });
//   </script>
// }